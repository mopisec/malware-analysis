import ctypes, ida_bytes, struct

def main():
    payload = bytearray(0x16000) # allocated at 0xE77D
    payload[4:8] = struct.pack('<I', ida_bytes.get_dword(0x18 + 4))
    payload[8:12] = struct.pack('<I', ida_bytes.get_dword(0x18 + 8))
    payload[0x30:0x34] = struct.pack('<I', ida_bytes.get_dword(0x18 + 0x30))
    payload[0x40:0x44] = struct.pack('<I', ida_bytes.get_dword(0x18 + 0x40))

    ebp_m4 = 0x18 + 0x50
    for i in range(4):
        data_addr = 0x18 + ida_bytes.get_dword(ebp_m4 - 4)
        copy_offset = ida_bytes.get_dword(ebp_m4 - 8)
        copy_size = ida_bytes.get_dword(ebp_m4)
        payload[copy_offset:copy_offset+copy_size] = idc.get_bytes(data_addr, copy_size)
        ebp_m4 += 0xC
    
    ebp_m4 = ida_bytes.get_dword(0x18 + 4)
    esi = 0x11000
    esi_p4 = struct.unpack('<I', payload[esi+4:esi+8])[0]
    while esi_p4 != 0:
        esi_p4 = struct.unpack('<I', payload[esi+4:esi+8])[0]
        for i in range((esi_p4 - 8) >> 1):
            offset = esi + i*2 + 8
            ext = struct.unpack('<H', payload[offset:offset+2])[0]
            ebp_m4 = ((ebp_m4 >> 0x10) + ext) | ((ebp_m4 << 0x10) & 0xFFFFFFFF)
        esi += esi_p4
        esi_p4 = struct.unpack('<I', payload[esi+4:esi+8])[0]
    
    payload[0x11000:0x111D0] = b'\x00' * 0x1D0

    ebp_mc = ida_bytes.get_dword(0x18 + 0x24)
    o_ecx = struct.unpack('<I', payload[ebp_mc:ebp_mc+4])[0]
    ecx = o_ecx
    o_eax = struct.unpack('<I', payload[ebp_mc+0x10:ebp_mc+0x10+4])[0]
    # ebp-40 : address of mem[o_eax]
    # ebp-38 : address of mem[o_ecx]
    ebx = struct.unpack('<I', payload[ebp_mc+0xC:ebp_mc+0xC+4])[0]
    ebp_m440 = bytearray(b'\xAB' * 0x500)
    ebp_m440[0] = payload[ebx] ^ (ebp_m4 & 0xFF)
    ebp_payloadC = (ebp_m4 << 0x18) & 0xFFFFFFFF
    ebp_m4 >>= 8
    ebp_m4 = ebp_m4 | ebp_payloadC
    ebp_m4 += payload[ebx]
    counter = 1
    while payload[ebx+1] != 0:
        ebx += 1
        ebp_m440[counter] = payload[ebx] ^ (ebp_m4 & 0xFF)
        ebp_payloadC = (ebp_m4 << 0x18) & 0xFFFFFFFF
        ebp_m4 >>= 8
        ebp_m4 = ebp_m4 | ebp_payloadC
        ebp_m4 = (ebp_m4 + ctypes.c_byte(payload[ebx]).value) & 0xFFFFFFFF
        counter += 1
    #print(ebp_m440) # KERNEL32.DLL
    
    eax = struct.unpack('<I', payload[ecx:ecx+4])[0]
    ebp_m20 = 0
    while True:
        ebx = eax + 2
        counter = 0
        while ebp_m440[counter-1] != 0:
            ebp_m440[counter] = payload[ebx] ^ (ebp_m4 & 0xFF)
            ebp_m30 = (ebp_m4 << 0x18) & 0xFFFFFFFF
            ebp_payloadC = ebp_m4 >> 8
            ebp_m4 = ebp_payloadC | ebp_m30
            ebp_m4 = (ebp_m4 + ctypes.c_byte(payload[ebx]).value) & 0xFFFFFFFF
            counter += 1
            ebx += 1
        #print(ebp_m440) # GetCurrentProcessId and GetSystemTime

        esi_offset = ida_bytes.get_dword(0x18 + 0x10)
        n = ebp_m4 % 5
        if n == 4:
            payload[esi_offset] = 0x75
        elif n == 3:
            payload[esi_offset] = 0x48
        elif n == 2:
            payload[esi_offset] = 0xFF
        elif n == 1:
            payload[esi_offset] = 0xE9
        elif n == 0:
            payload[esi_offset] = 0xE8
        esi_offset += 1

        ecx = 0
        payload[o_eax+ecx:o_eax+ecx+4] = struct.pack('<I', esi_offset) # to be accurate, this is not esi offset, its esi (esi_offset + allocated mem addr)
        ebx = 0xDEADBEEF # Address of GetCurrentProcessId or GetSystemTime
        ebx = (~ebx + 1) & 0xFFFFFFFF
        payload[esi_offset] = 0xB8
        payload[esi_offset+1] = ebx & 0xFF
        payload[esi_offset+2] = (ebx & 0xFFFF) >> 8
        ebp_m3C = ebx
        payload[esi_offset+3] = (ebx & 0xFFFFFF) >> (8*2)
        payload[esi_offset+4] = ebx >> (8*3)
        payload[esi_offset+5:esi_offset+5+4] = b'\xF7\xD8\xFF\xE0'
        esi_offset += 9

        ebp_m20 += 1
        edi_p24 = ida_bytes.get_dword(0x18 + 0x24)
        coff = struct.unpack('<I', payload[edi_p24:edi_p24+4])[0] + (ebp_m20 << 2)
        chk = struct.unpack('<I', payload[coff:coff+4])[0]
        if chk == 0:
            break
        eax = chk # ebx in real

    ebp_mc += 0x14
    chk = struct.unpack('<I', payload[ebp_mc:ebp_mc+4])[0]
    # chk must be 0

    edi_p28 = ida_bytes.get_dword(0x18 + 0x28)
    for i in range(edi_p28):
        eax = edi_p24 + i
        payload[eax] = 0

    print('entry point is :', hex(ida_bytes.get_dword(0x18 + 0x30)))

    with open('next_payload.bin', 'wb') as module_file:
        module_file.write(payload)

if __name__ == '__main__':
    main()
