import idaapi, idautils, idc
import re

# https://github.com/snemes/aplib/blob/master/src/aplib.py
import aplib

'''
.text:0041774B F7 43 44 00 00 00 40                 test    dword ptr [ebx+44h], 40000000h
.text:00417752 74 02                                jz      short loc_417756
.text:00417754 D1 CB                                ror     ebx, 1
'''
XORDEC_FUNC_PATTERN = rb'\xF7\x43\x44\x00\x00\x00\x40.{2}\xD1\xCB'

'''
.text:0040683B F7 40 44 00 00 00 40                 test    dword ptr [eax+44h], 40000000h
.text:00406842 74 02                                jz      short loc_406846
.text:00406844 D1 C8                                ror     eax, 1
.text:00406846 FF 75 08                             push    [ebp+arg_0]
.text:00406849 6A 08                                push    8
.text:0040684B 50                                   push    eax
'''
AHEAPM_FUNC_PATTERN = rb'\xF7\x40\x44\x00\x00\x00\x40.{2}\xD1\xC8\xFF\x75.\x6A\x08\x50'

def obtain_encrypted_data(xor_func_ea, heap_func_ea):
    ea = xor_func_ea
    encrypted_data = b''
    while ea != idc.BADADDR:
        if idc.print_insn_mnem(ea) == 'call' and idc.get_operand_value(ea, 0) == heap_func_ea:
            lea_insn = idc.prev_head(idc.prev_head(ea))
            encrypted_data_addr = idc.get_operand_value(lea_insn, 1)
            encrypted_data = idc.get_bytes(encrypted_data_addr, 
                                           idaapi.get_dword(encrypted_data_addr - 4))
            break
        ea = idc.next_head(ea)
    return encrypted_data

def obtain_xor_key(xor_func_ea):
    ea = xor_func_ea
    xor_key = 0
    while ea != idc.BADADDR:
        if idc.print_insn_mnem(ea) == 'xor' and idc.get_operand_type(ea, 1) == o_imm:
            xor_key = idc.get_operand_value(ea, 1)
        ea = idc.next_head(ea)
    return xor_key

def search_function(patt):
    result: list[int] = []

    for segment in idautils.Segments():
        segment_name = idc.get_segm_name(segment)
        segment_start_ea = idc.get_segm_start(segment)
        segment_end_ea = idc.get_segm_end(segment)
        segment_size = segment_end_ea - segment_start_ea
        segment_data = idc.get_bytes(segment_start_ea, segment_size)
        search_result = re.finditer(patt, segment_data)

        for matched in search_result:
            func_ea = ida_funcs.get_func(segment_start_ea + matched.start()).start_ea
            result.append(func_ea)
        
    return result

def main():
    search_result = search_function(XORDEC_FUNC_PATTERN)
    if len(search_result) < 1:
        print('[-] No XOR decoder function found. Please fix the search pattern.')
        return
    elif len(search_result) > 1:
        print('[-] More than one XOR decoder function found. Please fix the search pattern.')
        return
    xordec_func_ea = search_result[0]

    search_result = search_function(AHEAPM_FUNC_PATTERN)
    if len(search_result) < 1:
        print('[-] No allocHeapMemory function found. Please fix the search pattern.')
        return
    elif len(search_result) > 1:
        print('[-] More than one allocHeapMemory function found. Please fix the search pattern.')
        return
    aheapm_func_ea = search_result[0]

    encrypted_data = obtain_encrypted_data(xordec_func_ea, aheapm_func_ea)
    decrypted_data = b''
    xor_key = obtain_xor_key(xordec_func_ea)

    for i in range(len(encrypted_data)):
        decrypted_data += (encrypted_data[i] ^ xor_key).to_bytes(1, 'little')
    
    decompressed_data = aplib.decompress(decrypted_data)
    
    with open('decrypted_decompressed_code.bin', 'wb') as result_file:
        result_file.write(decompressed_data)

if __name__ == '__main__':
    main()