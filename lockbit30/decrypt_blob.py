import ida_bytes, idautils, idc, os

# https://github.com/snemes/aplib/blob/master/src/aplib.py
import aplib

# Directory to save decrypted blobs
OUTPUT_DIR = 'decrypted_blobs'

def generate_keystream(blob_seed, length):
    result = b''
    seed = blob_seed
    for i in range(length):
        seed = ((seed * 0x5851F42D4C957F2D) + 0x14057B7EF767814F) & 0xFFFFFFFFFFFFFFFF
        result += struct.pack('<Q', (seed * blob_seed) & 0xFFFFFFFFFFFFFFFF)
    return result

def process_blob(blob_seed, blob_addr, is_compressed=True):
    blob_size = ida_bytes.get_dword(blob_addr - 4)
    keystream = generate_keystream(blob_seed, blob_size)
    
    decrypted_data = b''
    encrypted_data = ida_bytes.get_bytes(blob_addr, blob_size)

    padding_size = 8 - (blob_size % 8)
    encrypted_data += b'\x00' * padding_size

    for i in range(0, blob_size, 8):
        # 00000000000000XX
        decrypted_data += (encrypted_data[i  ] ^ keystream[i  ]).to_bytes(1, 'little')
        # 0000XX0000000000
        decrypted_data += (encrypted_data[i+1] ^ keystream[i+5]).to_bytes(1, 'little')
        # 000000000000XX00
        decrypted_data += (encrypted_data[i+2] ^ keystream[i+1]).to_bytes(1, 'little')
        # 000000XX00000000
        decrypted_data += (encrypted_data[i+3] ^ keystream[i+4]).to_bytes(1, 'little')
        # 0000000000XX0000
        decrypted_data += (encrypted_data[i+4] ^ keystream[i+2]).to_bytes(1, 'little')
        # XX00000000000000
        decrypted_data += (encrypted_data[i+5] ^ keystream[i+7]).to_bytes(1, 'little')
        # 00000000XX000000
        decrypted_data += (encrypted_data[i+6] ^ keystream[i+3]).to_bytes(1, 'little')
        # 00XX000000000000
        decrypted_data += (encrypted_data[i+7] ^ keystream[i+6]).to_bytes(1, 'little')
    
    decrypted_data = decrypted_data[:-padding_size]

    if is_compressed:
        return aplib.decompress(decrypted_data)
    else:
        return decrypted_data

def find_blob_addr(ea):
    blob_addr = 0
    for _ in range(5):
        ea = idc.prev_head(ea)
        if idc.print_insn_mnem(ea) == 'push' and \
           idc.get_operand_type(ea, 0) == o_imm:
            blob_addr = idc.get_operand_value(ea, 0)
            break
    return blob_addr

def check_aplib_depack_called(ea):
    # todo: find function ea by regex
    aplib_func_ea = 0x418C44

    for _ in range(0x20):
        ea = idc.next_head(ea)
        if idc.print_insn_mnem(ea) == 'call' and \
           idc.get_operand_value(ea, 0) == aplib_func_ea:
            return True
    return False

def main():
    # todo: find function ea by regex
    decrypt_func_ea = 0x406DD4

    # todo: obtain automatically (from set_str_blob)
    # get_qword(0x426000)
    blob_seed = 0xe38f4742c189c399

    os.makedirs(OUTPUT_DIR, exist_ok=True)

    for ref in idautils.XrefsTo(decrypt_func_ea):
        blob_addr = find_blob_addr(ref.frm)
        if blob_addr == 0:
            print('[-] Failed to obtain blob data address used at ' + hex(ref.frm))
            continue
        else:
            print('[*] Attempting to decrypt and decompress blob at ' + hex(blob_addr))
        
        called = check_aplib_depack_called(ref.frm)
        result = process_blob(blob_seed, blob_addr, called)
        with open(OUTPUT_DIR + '/' + hex(blob_addr) + '.bin', 'wb') as result_file:
            result_file.write(result)

        print('[+] Success!')

if __name__ == '__main__':
    main()