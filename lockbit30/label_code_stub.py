import idautils, idc, json, re, struct

def obtain_xor_key(stub_func_ea):
    ea = stub_func_ea
    xor_key = 0
    while xor_key == 0:
        if idc.print_insn_mnem(ea) == 'xor' and \
           idc.get_operand_type(ea, 1) == idc.o_imm:
            xor_key = idc.get_operand_value(ea, 1)
        ea = idc.next_head(ea)
    return xor_key

def main():
    with open('C:\\Users\\gcc\\Downloads\\z2a_lockbit\\api_hash_dict.json', 'r') as input_file:
        api_hash_dict = json.load(input_file)
    
    # todo: search by pattern
    stub_func_ea = 0x405D98

    xor_key= obtain_xor_key(stub_func_ea)
    
    for ref in idautils.XrefsTo(stub_func_ea):
        ea = idc.prev_head(ref.frm)
        ptr_codestub = idc.get_operand_value(ea, 0) + 4
        ea = idc.prev_head(ea)
        data_addr = idc.get_operand_value(ea, 0) + 4
        
        encrypted_hash = struct.unpack('<I', idc.get_bytes(data_addr, 4))[0]
        while encrypted_hash != 0xCCCCCCCC:
            decrypted_hash = encrypted_hash ^ 0x19039FF6
            try:
                api_name = api_hash_dict[str(decrypted_hash)]
            except KeyError:
                print('[-] API hash not found: ' + str(decrypted_hash))
                ptr_codestub += 4
                data_addr += 4
                encrypted_hash = struct.unpack('<I', idc.get_bytes(data_addr, 4))[0]
                continue
            if ida_bytes.del_items(ptr_codestub, 0, 4) and idc.create_dword(ptr_codestub) != 0:
                idc.set_name(ptr_codestub, "api_" + api_name, 0x800)
                print('[+] Renamed DWORD at ' + hex(ptr_codestub) + ' to ' + api_name)
            else:
                print('[-] Something went wrong :(')
            ptr_codestub += 4
            data_addr += 4
            encrypted_hash = struct.unpack('<I', idc.get_bytes(data_addr, 4))[0]

if __name__ == '__main__':
    main()