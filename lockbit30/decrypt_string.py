import ida_funcs, idc, re

'''
.text:00401248 81 31 F6 9F 03 19                 xor     dword ptr [ecx], 19039FF6h
.text:0040124E F7 11                             not     dword ptr [ecx]
.text:00401250 90                                nop
.text:00401251 83 C1 04                          add     ecx, 4
.text:00401254 4A                                dec     edx
'''
STRDEC_FUNC_PATTERN = rb'\x81\x31.{4}\xf7\x11\x90\x83\xC1\x04\x4A'

def obtain_xor_key(func_ea):
    func = ida_funcs.get_func(func_ea)
    ea = func.start_ea
    while ea != func.end_ea:
        if idc.print_insn_mnem(ea) == 'xor' and \
           idc.get_operand_type(ea, 1) == idc.o_imm:
            return idc.get_operand_value(ea, 1)
        ea = idc.next_head(ea)
    return 0

def obtain_decrypted_string(call_ea, xor_key):
    ea = call_ea
    result = b''
    while idc.print_insn_mnem(ea) != 'mov' or \
          idc.get_operand_type(ea, 1) != idc.o_imm or \
          '+' in idc.generate_disasm_line(ea, 0):
        ea = idc.prev_head(ea)
    while idc.print_insn_mnem(ea) == 'mov' and \
          idc.get_operand_type(ea, 1) == idc.o_imm:
        encrypted_data = idc.get_operand_value(ea, 1) & 0xFFFFFFFF
        result += struct.pack('<I', ~(encrypted_data ^ xor_key) & 0xFFFFFFFF)
        ea = idc.next_head(ea)
    return result

def search_function(patt):
    result: list[int] = []

    for segment in idautils.Segments():
        segment_name = idc.get_segm_name(segment)
        segment_start_ea = idc.get_segm_start(segment)
        segment_end_ea = idc.get_segm_end(segment)
        segment_size = segment_end_ea - segment_start_ea
        segment_data = idc.get_bytes(segment_start_ea, segment_size)
        search_result = re.finditer(patt, segment_data)

        for matched in search_result:
            func_ea = ida_funcs.get_func(segment_start_ea + matched.start()).start_ea
            result.append(func_ea)
        
    return result

def main():
    search_result = search_function(STRDEC_FUNC_PATTERN)
    if len(search_result) != 1:
        print('[-] More than one string decryptor function found. Please fix the search pattern.')
        return
    strdec_func_ea = search_result[0]

    xor_key = obtain_xor_key(strdec_func_ea)
    
    for ref in idautils.XrefsTo(strdec_func_ea):
        decrypted_str = obtain_decrypted_string(ref.frm, xor_key)
        decrypted_str_unicode = decrypted_str.decode('utf-16', errors='ignore')

        print('[+] Decrypted string at ' + hex(ref.frm))
        idc.set_cmt(ref.frm, str(decrypted_str) + '\nDecoded as an unicode string: ' + decrypted_str_unicode, False)

if __name__ == '__main__':
    main()