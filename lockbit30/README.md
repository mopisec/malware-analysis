# LockBit 3.0

SHA256 hash of the sample: `a5e6df754a4d3bb72f4d5c91d6b582e7e2c2f87ca838f5d976bc82384a5ad2d1`

## API hashing routine

`sub_405AE4` is API resolver function, according to the code in `sub_406390`.
It dynamically resolves API function from passed hash value, and returns pointer of the function.

```c
  result = sub_405AE4(0xF80F18E8);
  if ( result )
  {
    result = ((int (__stdcall *)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))result)(266242, 0, 0, 0, 0, 0);
```

API resolver function will internally call two hashing function, `sub_4011C0` and `sub_40117C`, each for DLL filename and API function name.
These two function will both calculate hash value for string stored inside passed buffer using ROR operation.
Just one expect here, that `sub_4011C0` (hashing function for DLL filename) will OR-es 0x20 when character inside the string is in between 0x41 and 0x5A.
Following is the decompiled code of each function.

```c
int __stdcall sub_4011C0(_WORD *dll_name_buf, int hash_value)
{
  int dll_char; // eax

  HIWORD(dll_char) = 0;
  do
  {
    LOWORD(dll_char) = *dll_name_buf++;
    if ( (unsigned __int16)dll_char >= 0x41u && (unsigned __int16)dll_char <= 0x5Au )
      LOWORD(dll_char) = dll_char | 0x20;
    hash_value = dll_char + __ROR4__(hash_value, 13);
  }
  while ( dll_char );
  return hash_value;
}
```

```c
int __stdcall sub_40117C(_BYTE *a1, int hash_value)
{
  int api_char; // eax

  api_char = 0;
  do
  {
    LOBYTE(api_char) = *a1++;
    hash_value = api_char + __ROR4__(hash_value, 13);
  }
  while ( api_char );
  return hash_value;
}
```

From these information, I have wrote a python script that mappes hash value and API function name, so I can easily identify which API function is used at certain point in this sample.

> [build_api_hash_dict.py](./build_api_hash_dict.py)

Also I have wrote a IDAPython script that automatically finds / calculates the hash value, and set comment with its resolved API function name.

> [resolve_api.py](./resolve_api.py)

Following image shows what I got after executing 2 scripts above.

![Figure 1](img/fig1.jpg)

## Calling API function via code stubs

After resolving some APIs (such as `RtlCreateHeap`, `HeapAlloc`), sample was calling function `sub_405D98` multiple times.
This function is for creating code stubs that calls API function indirectly.
Function will first XOR decrypt hardcoded API hash value using key `0x19039FF6`, then obtain a address of API function using it.
Then it will allocate a memory for 16 bytes, and write codes that jumps to address of API function.
There are few patterns of code (which will be used is determined randomly), and each will decrypt the address using different method (ROL, ROR, XOR, ROL+XOR, ROR+XOR).
At the end, it will write a address of allocated memory (code) to certain address like `dword_425414`.

I have wrote an IDAPython script that label the code stubs with API function name automatically to deal with this technique.

> [label_code_stub.py](./label_code_stub.py)

Following is what I got after executing the script (where it calls API function indirectly).

**Before:**

![Figure 2](img/fig2.jpg)

**After:**

![Figure 3](img/fig3.jpg)

## Anti-debugging technique using ThreadHideFromDebugger

Sample will call `NtSetInformationThread` API function by specifying `0x11 = ThreadHideFromDebugger` as a `ThreadInformationClass` in `sub_40B434`.
This will make debuggers unable to obtain information about the thread, so this is one of the anti-debug technique implemented in this sample.

```c
int __stdcall sub_40B434(int a1)
{
  int v1; // eax

  if ( a1 )
    v1 = a1;
  else
    v1 = -2;
  return api_NtSetInformationThread(v1, 0x11, 0, 0);// 0x11 = ThreadHideFromDebugger
}
```

## Anti-debugging technique using RtlCreateHeap

Interesting anti-debugging technique (which was first see for me) was used in this sample.
At `sub_406390`, I have found code like below.

![Figure 4](img/fig4.jpg)

It gets value at offset 0x44 of hHeap (pointer to `_HEAP` structure, return value of the `RtlCreateHeap` function), and checks if `HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)` flag is set or not.
If its set, it will rotate the hHeap to right for 1-bit.
First this sounded very strange for me, because rotating the pointer to structure is meaningless, and it does not make any sense.
Answer was that its one of anti-debug technique used in this sample.
When debugger is active, offset 0x44 of hHeap (named `ForceFlags`) will be non-zero value.
So this was for corrupting hHeap value under debugger environment.
Following article describes more about this technique, so I will recommend you to check it out.

> Anti Debugging Protection Techniques with Examples  
https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software#p4

## Encrypted strings

This sample contains a lot of encrypted string, and following is the one of it.

![Figure 5](img/fig5.jpg)

Its observable that some values are stored using stackstring method, and passed to the another function `sub_40123C`. 
This function does XOR decryption using key 0x19039FF6, then does NOT operation to the decrypted value.
I wrote an IDAPython script that finds encrypted string and decrypt it automatically.

> [decrypt_string.py](./decrypt_string.py)

I have devised some functionality to enhance my further analysis:

- It will automatically finds XOR key and encrypted string using regex
- Since some of them were UTF-16 string, I made script to also display UTF-16 decoded string

Following is what I got after executing the script.

![Figure 6](img/fig6.jpg)

## Encrypted blobs

There are multiple encrypted blobs that are decrypted along the execution.

![Figure 7](img/fig7.jpg)

These data are XOR encrypted by certain keystream, which is generated from code decrypted at function `sub_417738`.
Keystream generation code was single-byte XOR encrypted (key was 0x30 for this sample), and also compressed using aPLib algorithm.
Hopefully, there was a publicly available Python script that can decompress aPLib compressed data, so I have used it to write IDAPython script that will decrypt and decompress the keystream generation code.

> Module I have used to decompress aPLib blob by snemes  
https://github.com/snemes/aplib

> [decrypt_decompress_code.py](./decrypt_decompress_code.py)

Following is the decompiled code of the code that I have extracted using the script above.

```c
__int64 __stdcall sub_83(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rax

  v2 = mul_qword(*a2, 0x5851F42D4C957F2Di64) + 0x14057B7EF767814Fi64;
  *a2 = v2;
  return mul_qword(*a1, v2);
}
```

Function `mul_qword` is just taking product of two 64-bit integer passed to it.
First argument of this function is `0xe38f4742c189c399` (QWORD written at `0x426000`) and second argument is address `0x426000`.
8 bytes of data are decrypted at once, and keystream will be regenerated each time.
Keystream will be different value each time, because value in `0x426000` will be overwritten every time function is called.
Based on this information, I wrote a keystream generator in Python, along the code that finds and decrypt encrypted blobs automatically.

> [decrypt_blob.py](decrypt_blob.py)

Note that some of the blobs cannot be decrypted by this script, if the code is passing address of blob by unusual way.
However, it is still possible to decrypt and decompress by calling `process_blob` function in the script manually from the interpreter.

There were lots of interesting data (including strings) inside these blobs, so I have made a table that briefly explains / guesses what each blobs are for.
Check it out from [here](#appendix--data-inside-encrypted-blobs)!

## Investigate config blob

First blob that will be decrypted and decompressed is located at `0x42600C`.
I have named this config blob, because sample branches how it acts depending on flags and strings stored inside this blob.
Since this address is passed to the function by iregular way, I started by decrypting / decompressing it manulaly.

```py
dec_data = process_blob(0xe38f4742c189c399, 0x426000+4*3, True)
```

There were 6 base64 encoded string in there.
However, as the code shows, there should be 8 string in maximum.

### 1st base64 encoded string

Decoded data contains multiple hashes, which will be used at `sub_40F2B4`.

Since bruteforcing them were almost impossible, I googled them and found awesome project that uses dictionary to find original value of the hash.

> sisoma2/malware_analysis/blackmatter - GitHub  
https://github.com/sisoma2/malware_analysis/tree/master/blackmatter

Following are the hashes and its original value (gained from the [page above](https://github.com/sisoma2/malware_analysis/tree/master/blackmatter)):

- 0x30a212d - $recycle.bin
- 0x8cf281cd - config.msi
- 0x267078f5 - $windows.~bt
- 0x26687e35 - $windows.~ws
- 0xe3426cd7 - windows
- 0xc6ce6958 - appdata
- 0xa6f2d1a7 - application data
- 0xe1a63bc0 - boot
- 0x52cb0b38 - google
- 0xdccab8dd - mozilla
- 0x36004e4e - program files
- 0xab086595 - program files (x86)
- 0x2e75e394 - programdata
- 0xae018eae - system volume information
- 0x4c4b25d4 - tor browser
- 0x7f07935 - windows.old
- 0x6b66f975 - intel
- 0xb7ea3892 - msocache
- 0x5366e694 - perflogs
- 0xcd1b589b - x64dbg (\*1)
- 0x5cde3a7b - public
- 0xba22623b - all users
- 0xef3a37b3 - default

(\*1): There was no information about this hash, so I have bruteforced various directories / program names to find it. It may be wrong, since there are multiple string that leads to this hash value.

### 2nd base64 encoded string

Decoded data contains multiple hashes, which will be used at `sub_40F21C`.

Following are the hashes and its original value (gained from the [page above](https://github.com/sisoma2/malware_analysis/tree/master/blackmatter)):

- 0x86ccaa15 - autorun.inf
- 0x3907099b - boot.ini
- 0xf00cae96 - bootfont.bin
- 0xfcc8ab56 - bootsect.bak
- 0x82d2a252 - desktop.ini
- 0x846bec00 - iconcache.db
- 0xdb975937 - ntldr
- 0xc23aa6f5 - ntuser.dat
- 0x85aa57e4 - ntuser.dat.log
- 0xcbe2aa35 - ntuser.ini
- 0xc8cef7d1 - thumbs.db

### 3rd base64 encoded string

Decoded data contains multiple hashes, which will be used at `sub_40F21C`.

Following are the hashes and its original value (gained from the [page above](https://github.com/sisoma2/malware_analysis/tree/master/blackmatter)):

- 0x67b00e00 - 386
- 0xc5b01900 - adv
- 0xc5481b80 - ani
- 0xc7a01840 - bat
- 0xc7701a40 - bin
- 0xc9101840 - cab
- 0xc9201b40 - cmd
- 0xc9681bc0 - com
- 0xc9601c00 - cpl
- 0xc9901d40 - cur
- 0xa1fccbfe - deskthemepack
- 0x4aba94f1 - diagcab
- 0x4ae29631 - diagcfg
- 0x64e29771 - diagpkg
- 0xcb601b00 - dll
- 0xcbb01c80 - drv
- 0xcd281e00 - exe
- 0xd3801b00 - hlp
- 0xd56018c0 - icl
- 0xc99eab80 - icns
- 0xd57818c0 - ico
- 0xd59818c0 - ics
- 0xd5c01900 - idx
- 0xdb301900 - ldf
- 0xdb581b80 - lnk
- 0xdd201bc0 - mod
- 0xdd081c00 - mpa
- 0xdd181cc0 - msc
- 0xdd801cc0 - msp
- 0x4a6bb7db - msstyles
- 0xdda81cc0 - msu
- 0xdf981b00 - nls
- 0x4cca7837 - nomedia
- 0xe1c018c0 - ocx
- 0xe3301c80 - prf
- 0xe1881cc0 - ps1
- 0xe7681bc0 - rom
- 0xe7801d00 - rtp
- 0xe99018c0 - scr
- 0xe9981a00 - shs
- 0xe9601c00 - spl
- 0xe9981e40 - sys
- 0xcd2e9b7a - theme
- 0xaf16c593 - themepack
- 0xf1c01c00 - wpx
- 0xe15ed8c0 - lock
- 0xd9c81940 - key
- 0xd3081d00 - hta
- 0xdd481cc0 - msi
- 0xe3101900 - pdb

### 4th base64 encoded string

**Not present in this sample.**

Decoded data contains multiple hashes, which will be used at `sub_410E30`.
`sub_410E30` will call `sub_40C8B4` which obtains computer name, and compare its hash with the hashes in decoded data.

### 5th base64 encoded string

Decoded data contained multiple UTF-16 strings like below:

- sql
- oracle
- ocssd
- dbsnmp
- synctime
- agntsvc
- isqlplussvc
- xfssvccon
- mydesktopservice
- ocautoupds
- encsvc
- firefox
- tbirdconfig
- mydesktopqos
- ocomm
- dbeng50
- sqbcoreservice
- excel
- infopath
- msaccess
- mspub
- onenote
- outlook
- powerpnt
- steam
- thebat
- thunderbird
- visio
- winword
- wordpad
- notepad

These are the name of processes that will be terminated by the sample.
For the detail, check [Terminate processes in config blob](#terminate-processes-in-config-blob).

### 6th Base64 encoded string

Decoded data contained multiple UTF-16 strings like below:

- vss
- sql
- svc$
- memtas
- mepocs
- msexchange
- sophos
- veeam
- backup
- GxVss
- GxBlr
- GxFWD
- GxCVD
- GxCIMgr

These are the name of services that will be terminated and deleted by the sample.
For the detail, check [Terminate and delete services in config blob](#terminate-and-delete-services-in-config-blob).

### 7th Base64 encoded string

**Not present in this sample.**

It is been used at `sub_40CFBC`.
Because its data is passed to `InternetConnectW` API function, this data should contain C2 server address.

### 8th Base64 encoded string

8th decoded data was been encrypted using same method as blob.

```c
            possible_b64decode(v28, (char *)ptr_base64_decoded_7);// dec_data[0x67D:-1]
            size = v30;
            personal_id_generator(v32);
            decrypt_data((_BYTE *)ptr_base64_decoded_7, size);
```

I have slightly modified my script so it can receive bytes of blob as an argument, so I can decrypt this small blob.

> [decrypt_small_blob.py](decrypt_small_blob.py)

Script outputted the ransomnote.

```
b"~~~ LockBit 3.0 the world's fastest and most stable ransomware from 2019~~~\r\n\r\n>>>>> Your data is stolen and encrypted.\r\nIf you don't pay the ransom <...SNIP...> If you do not pay the ransom, we will attack your company again in the future."
```

I have also discovered that `sub_406ED0` is for generating `personal ID` written inside ransomnote.
It will get first 8 bytes of config blob and hexlify it, then append random 8 bytes, and use it as personal ID.

## Checking language and flag

This sample will call `ExitProcess` API when `byte_425124` and return value of function `sub_4080A8` is non-zero value.

```c
  if ( byte_425124 && sub_4080A8() )
    api_ExitProcess(0);
```

`byte_425124` corresponds with byte at offset 0xA4 of config blob.
I have confirmed that its value is `1` (non-zero).

```
Python>dec_data[164]
0x1
```

`sub_4080A8` will call `NtQueryInstallUILanguage` and `NtQueryDefaultUILanguage` first, and check if returned language ID matches the value below. If it matches with any of them, function will return 1.

- ru-RU - Russian
- uk-UA - Ukrainian
- be-BY - Belarusian
- tg-Cyrl-TJ - Tajik
- hy-AM - Armenian - Armenia
- az-Latn-AZ - Azeri (Latin)
- ka-GE - Georgian
- kk-KZ - Kazakh
- ky-KG - Kyrgyz (Cyrillic)
- tk-TM - Turkmen
- uz-Latn-UZ - Uzbek (Latin)
- tt-RU - Tatar
- ro-MD - Romanian - Moldava
- ru-MD - Russian - Moldava
- az-Cyrl-AZ - Azeri (Cyrillic)
- uz-Cyrl-UZ - Uzbek (Cyrillic)
- ar-SY - Arabic - Syria

This concludes that `sub_4080A8` is for checking language of the system, and stop infection when certain language is detected.
However, if byte at offset 0xA4 of config blob is `1`, it will ignore this check and continue infection.

## UAC bypass

Sample will attempt UAC bypass if following condition is true:

- `S-1-5-32-544 - BUILTIN\Administrators` is not enabled in an access token
- OS version is equal or higher than Windows 7 / Windows Server 2008 R2
- Group accounts associated with the token includes `S-1-5-32-544 - BUILTIN\Administrators`

It will first overwrite its image path name and commandline to `C:\Windows\System32\dllhost.exe` , `"C:\Windows\System32\dllhost.exe"`.
I guess sample is trying to maquerade itself as a `dllhost.exe` to disturb dynamic analysis.
This technique is mentioned deeply at the page below.

> Masquerading Processes in Userland via _PEB  
https://www.ired.team/offensive-security/defense-evasion/masquerading-processes-in-userland-through-_peb

Then it will attempt UAC bypass using COM interface of CMSTPLUA.
As CMSTPLUA has the `Auto Approval` attribution enabled, UAC prompt will not be displayed when its elevated.
Following COM elevation moniker string (specifying CLSID of CMSTPLUA) and interface ID (IID) of ICMLuaUtil was decrypted and used there.

```
Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}
```

```
b'tm\xddn\x07\xc0uN\xb7j\xe5t\t\x95\xe2L'

-> {6EDD6D74-C007-4E75-B76A-E5740995E24C}
```

It will re-execute it self by using `ShellExec` method in ICMLuaUtil to bypass UAC and elevate its privilege.
PoC code on following gist helped me a lot to analyze this part.

> akagi_41.c by api0cradle  
https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512

## File extension

Sample will create unique file extension for encrypted file using MD5 and Base64 algorithm at function `sub_406D2C`.
Following is the procedure of how it generates file extension:

1. Calculate MD5 hash of 128 bytes of config blob mentioned at [Investigate config blob](#investigate-first-blob)
    - `3b97076475ac43dd3f75a75a4b1206ef`
2. Format into GUID string
    - `{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}`
    - `{6407973B-AC75-DD43-3F75-A75A4B1206EF}`
3. Calculate MD5 hash of GUID string
    - `21cb015780c1a32230bbd42153ccb514`
4. Base64 encode the MD5 hash
    - `IcsBV4DBoyIwu9QhU8y1FA==`
5. Null terminate 9th character of Base64 encoded string
    - `IcsBV4DBo`
6. Replace `+` with `x`, `/` with `i`, and `=` with `z`
    - Not performed in this sample

As a result, file extension of this sample was `.IcsBV4DBo`.
Filename of README file (ransomnote) will be also generated using it.

```
IcsBV4DBo.README.txt
```

It will create registry key that makes system to display LockBit icon (stored in encrypted blob at 0x41BA1C) on file with generated extension.
Icon file will be stored in `C:\ProgramData\IcsBV4DBo.ico` (path `C:\ProgramData` depends on the value of `CSIDL_COMMON_APPDATA`).

![Icon image of LockBit](img/lockbit_icon.jpg)

Registry key `HKEY_CLASSES_ROOT\.IcsBV4DBo\DefaultIcon` will be modified and value will be the `C:\ProgramData\IcsBV4DBo.ico`.
To immediately display (render) the icon placed, it will call `SHChangeNotify` API function.

## Command line argument

At `sub_417458`, sample is checking its command line argument and branching its flow.
Because it uses a hash (same algorithm used for DLL filename in API resolver function) to determine what argument is passed, I wrote a Python script that will bruteforce and find the original value.

> [bruteforce_hash.py](./bruteforce_hash.py)

I will write output of the script here, since it will take a while for execution.

```
[*] Attacking hash 0x45471d17
[+] Original value of hash 0x45471d17 is -path
[*] Attacking hash 0x459f1cd7
[+] Original value of hash 0x459f1cd7 is -pass
[*] Attacking hash 0x452f4997
[+] Original value of hash 0x452f4997 is -safe
[*] Attacking hash 0x45678b17
[+] Original value of hash 0x45678b17 is -wall
[*] Attacking hash 0x69268c17
[+] Original value of hash 0x69268c17 is -gspd
[*] Attacking hash 0x69c71957
[+] Original value of hash 0x69c71957 is -psex
[*] Attacking hash 0xcb62e940
[+] Original value of hash 0xcb62e940 is -del
[*] Attacking hash 0x4b668957
[+] Original value of hash 0x4b668957 is -gdel
```

Discovered that there are 8 types of command line argument is available.

## Mutex

Sample will create mutex to prevent multiple execution.
Following is the procedure of how it generates mutex:

1. Calculate MD5 hash of 128 bytes of config blob mentioned at [Investigate config blob](#investigate-first-blob)
    - `3b97076475ac43dd3f75a75a4b1206ef`
2. Format into GUID string
    - `{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}`
    - `{6407973B-AC75-DD43-3F75-A75A4B1206EF}`
    - Same until here as [File Extension](#file-extension)
3. Calculate hash (algorithm used at [API hashing routine](#api-hashing-routine) for DLL filename) of GUID string
    - 0x250ce867
4. Calculate MD4 hash of calculated hash
    - `d88536b9767539652aa7ca19c4460a2f`
5. Format into string
    - `Global\%.8x%.8x%.8x%.8x`
    - `Global\b93685d86539757619caa72a2f0a46c4`

As a result, mutex of this sample was `Global\b93685d86539757619caa72a2f0a46c4`.

## Killing Windows Defender

If byte at offset 0xAF of config blob is `1`, sample will delete services of Windows Defender in `sub_408BD0`.

```
Python>dec_data[0xAF]
0x1
```

Following is the decompiled code of sample where it deletes Windows Defender services:

```c
        v12 = 0xE3823BF2;
        v11 = 0xE42EE5F5;
        v10 = 0xC46F5935;
        v9 = 0xE1D75A35;
        v8 = 0xB7BA4173;
        v7 = 0x6AFA4DBA;
        v6 = 0xEAEB1DB8;
        v5 = 0x5F2E6CFA;
        v4 = 0x616E5B6A;
        service_name = Heap;
        do
        {
          service_hash = hash_dll(*service_name, 0);
          if ( service_hash == v12
            || service_hash == v11
            || service_hash == v10
            || service_hash == v9
            || service_hash == v8
            || service_hash == v7
            || service_hash == v6
            || service_hash == v5
            || service_hash == v4 )
          {
            hService = api_OpenServiceW(hSCManager, *service_name, 65568);
            if ( hService )
            {
              api_memset(v3, 0, 28);
              api_ControlService(hService, 1, v3);
              api_DeleteService(hService);
              api_CloseServiceHandle(hService);
            }
          }
```

It is checking whether service is from Windows Defender using hashes.
I wrote and ran following Python script to discover which hash corresponds with which service.

> [find_service_by_hash.py](./find_service_by_hash.py)

Scripts outputs result like below:

```
[+] Hash 0x616e5b6a cracked: SecurityHealthService
[+] Hash 0x5f2e6cfa cracked: Sense
[+] Hash 0xeaeb1db8 cracked: sppsvc
[+] Hash 0xe3823bf2 cracked: WdBoot
[+] Hash 0xe42ee5f5 cracked: WdFilter
[+] Hash 0xc46f5935 cracked: WdNisDrv
[+] Hash 0xe1d75a35 cracked: WdNisSvc
[+] Hash 0xb7ba4173 cracked: WinDefend
[+] Hash 0x6afa4dba cracked: wscsvc
```

Now I knew that these 9 services are been deleted by sample.

## Secure deletion against files and directories inside $RECYCLE.BIN\\S-* for all drives

Sample will attempt secure deletion of files and directories inside `$RECYCLE.BIN\\S-*` directory in all drives at `sub_407458`.
Following is the process of how it deletes files inside `$RECYCLE.BIN\\S-*` (and its sub-directory):

1. Overwrite content of file with random value
    - Generated using `rdseed / rdrand` instruction on supported hardware
    - If hardware does not support, it will generate value using RDTSC and ROR13
2. Rename file to `AAAAAAAAAAAAAAAAAAAAAAAAAAA`
3. Delete file using `DeleteFileW` API function

I assume this is anti-forensic technique, so that forensic investigator cannot recover files from `$RECYCLE.BIN\\S-*` directory.

## Delete VSS snapshot

Sample will attempt to delete VSS snapshots using 2 COM interfaces `IWbemLocator` and `IWbemContext`.
It will query VSS snapshots using WQL statement `SELECT * FROM Win32_ShadowCopy`, get its ID, and delete using `IWbemServices::DeleteInstance` method.
Following is the decompiled code of `sub_40781C`, where the deletion is attempted.

```c
      if ( !iwl->lpVtbl->ConnectServer(iwl, (const BSTR)wstr_ROOT_CIMV2, 0, 0, 0, 0, 0, iwc, &sws)
        && !api_CoSetProxyBlanket(sws, 10, 0, 0, 3, 3, 0, 0)
        && !sws->lpVtbl->ExecQuery(
              sws,
              (const BSTR)wstr_WQL,             // WQL
              (const BSTR)wstr_wql_select_shadowcopy,// SELECT * FROM Win32_ShadowCopy
              WBEM_FLAG_SYSTEM_ONLY,
              0,
              &swo) )
      {
        while ( 1 )
        {
          pObj = 0;
          v14 = 0;
          if ( swo->lpVtbl->Next(swo, -1, 1, &pObj, (ULONG *)&v14) )
            break;
          api_VariantInit(&variant);
          if ( !pObj->lpVtbl->Get(pObj, (LPCWSTR)wstr_ID, 0, &variant, 0, 0) )// ID
          {
            api_swprintf(v1, win32_shadowcopy_id_format_str, variant.lVal);// Win32_ShadowCopy.ID='%s'
            sws->lpVtbl->DeleteInstance(sws, (const BSTR)v1, 0, 0, 0);
            api_VariantClear(&variant);
          }
          pObj->lpVtbl->Release(pObj);
        }
      }
```

## Terminate and delete services in config blob

If byte at offset 0xA8 of config blob is `1`, sample will terminate and delete services written inside 6th base64 decoded data in config blob at `sub_407C94`.

```
Python>dec_data[0xA8]
0x1
```

Following is the decompiled code of sample where it terminates and deletes services:

```c
s = lpServices;
        do
        {
          result = (ENUM_SERVICE_STATUS_PROCESS *)find_str_from_6th_b64decoded_data((int)s->lpServiceName);
          if ( result )
          {
            result = (ENUM_SERVICE_STATUS_PROCESS *)api_OpenServiceW(hSCManager, s->lpServiceName, 65568);
            hService = result;
            if ( result )
            {
              api_memset(v3, 0, 28);
              if ( !api_ControlService(hService, 1, v3) )
              {
                api_memset(&service_status, 0, 36);
                if ( api_QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, &service_status, 36, v4) )
                  terminate_process_by_pid(service_status.dwProcessId);
              }
              api_DeleteService(hService);
              result = (ENUM_SERVICE_STATUS_PROCESS *)api_CloseServiceHandle(hService);
            }
          }
          ++s;
          --v5;
        }
        while ( v5 );
```

## Terminate processes in config blob

If byte at offset 0xA7 of config blob is `1`, sample will terminate processes written inside 5th base64 decoded data in config blob at `sub_417034`.

```
Python>dec_data[0xA7]
0x1
```

Following is the decompiled code of sample where it terminates processes:


```c
      spi = ptr_buffer;
      do
      {
        NextEntryOffset = spi->NextEntryOffset;
        if ( spi->ImageName.Buffer )
        {
          if ( find_str_from_5th_b64decoded_data((int)spi->ImageName.Buffer) )
          {
            client_id.UniqueProcess = spi->UniqueProcessId;
            client_id.UniqueThread = 0;
            oattr.Length = 24;
            memset(&oattr.RootDirectory, 0, 20);
            if ( !api_NtOpenProcess(&v8, 1, &oattr, &client_id) )
            {
              api_NtTerminateProcess(v8, 0);
              api_NtClose(v8);
            }
          }
        }
        spi = (SYSTEM_PROCESS_INFORMATION *)((char *)spi + NextEntryOffset);
      }
```

## ToDo

- Discover which base64 decoded data is used for what
- Discover what each command line argument does
- Find and analyze actual functionality of ransomware (like encrypting user's file)
- Analyze more deep around UAC bypass
    - Not fully understood (esp. `sub_40B664`, `sub_40E2A8`)
- Discover rest of data in config blob
- Find some clever way to reverse hash to original value
    - Other than bruteforce. This needs a lots of time.
    - There are lot of collision in hash

## Appendix : YARA rule

Also available at [here](./lockbit30_ransomware.yar).

```yara
rule lockbit30_ransomware
{
    meta:
        author = "@mopisec <contact@mopisec.net>"
        date = "2023-05-02"
        description = "Rule to detect LockBit 3.0 (a.k.a. LockBit Black) ransomware"

    strings:
        $string0 = {F7 43 44 00 00 00 40 ?? ?? D1 CB}
        $string1 = {F7 40 44 00 00 00 40 ?? ?? D1 C8 FF 75 ?? 6A 08 50}
        $string2 = {81 31 ?? ?? ?? ?? F7 11 90 83 C1 04 4A}
        $string3 = {0F EF C0 0F EF C9 33 C0 40 C1 E0 ??}

    condition:
        uint16(0) == 0x5A4D and 
        uint32(uint32(0x3C)) == 0x00004550 and
        3 of them
}
```

## Appendix : IOCs

### SHA256 Hashes

- PE Files
    - a5e6df754a4d3bb72f4d5c91d6b582e7e2c2f87ca838f5d976bc82384a5ad2d1
    - 917e115cc403e29b4388e0d175cbfac3e7e40ca1742299fbdb353847db2de7c2
    - 63c8efca0f52ebea1b3b2305e17580402f797a90611b3507fab6fffa7f700383
    - 289ffbeb2d2916c7273b75f4e96ee972b761c8b4d1ae3a84ef3f090e3802d679
- Icon File
    - 95e059ef72686460884b9aea5c292c22917f75d56fe737d43be440f82034f438

## Appendix : Structure of config blob

| Offset | Detail | Remark |
|------|---|-------------------------|
| 0x000 | First half of personal ID written inside the ransomnote. | Rest half of the ID is random value, so TA might be using this value to identify which client is the victim running. |
| 0x008 |  | Not investigated yet. |
| 0x0A0 |  |  |
| 0x0A1 |  |  |
| 0x0A2 |  |  |
| 0x0A3 |  |  |
| 0x0A4 | Flag whether to detect specific language and exit process. | [Checking language and flag](#checking-language-and-flag)  |
| 0x0A5 |  |  |
| 0x0A6 |  |  |
| 0x0A7 | Flag whether to terminate processes in Base64 encoded string 5. | [Terminate processes in config blob](#terminate-processes-in-config-blob) |
| 0x0A8 | Flag whether to terminate and delete services in Base64 encoded string 6. | [Terminate and delete services in config blob](#terminate-and-delete-services-in-config-blob) |
| 0x0A9 |  |  |
| 0x0AA |  |  |
| 0x0AB |  |  |
| 0x0AC |  |  |
| 0x0AD |  |  |
| 0x0AE |  |  |
| 0x0AF | Flag whether to delete services of Windows Defender. | [Killing Windows Defender](#killing-windows-defender) |
| 0x0B0 |  |  |
| 0x0B1 |  |  |
| 0x0B2 |  |  |
| 0x0B3 |  |  |
| 0x0B4 |  |  |
| 0x0B5 |  |  |
| 0x0B6 |  |  |
| 0x0B7 |  |  |
| 0x0B8 | Offset(\*1) of Base64 encoded string 1. |  |
| 0x0BC | Offset(\*1) of Base64 encoded string 2. |  |
| 0x0C0 | Offset(\*1) of Base64 encoded string 3. |  |
| 0x0C4 | Offset(\*1) of Base64 encoded string 4. | Value was 0 for this sample. |
| 0x0C8 |  | Not used? |
| 0x0CC | Offset(\*1) of Base64 encoded string 5. |  |
| 0x0D0 | Offset(\*1) of Base64 encoded string 6. |  |
| 0x0D4 | Offset(\*1) of Base64 encoded string 7. | Value was 0 for this sample. |
| 0x0D8 | Offset(\*1) of unknown data. | Value was 0 for this sample. |
| 0x0DC | Offset(\*1) of Base64 encoded string 8. |  |
| 0x0E0 | Base64 encoded string 1. | |
| 0x161 | Base64 encoded string 2. |  |
| 0x1A2 | Base64 encoded string 3. |  |
| 0x2B3 | Base64 encoded string 5. |  |
| 0x588 | Base64 encoded string 6. |  |
| 0x67D | Base64 encoded string 8. | Encrypted ransomnote. |

(\*1): Needs padding (0xB8) for offset calculation. If value is 0, it indicates that section does not exists.

## Appendix : Data inside encrypted blobs

| Address of encrypted blob | Remark                   |
|---------------------------| ------------------------ |
| 0x41b004 | Shorter version of text found at 0x41b0f8. |
| 0x41b0f8 | String present in wall paper created and setted by sample. |
| 0x41b25a | Unknown. Similar with data found at 0x41b3da. |
| 0x41b3da | Unknown. Since there is string `wtsapi32.dll`, it might be used in another API resolver function. |
| 0x41b8b2 | Another part of ransomnote with onion URL and decryption ID (that is filled using format string). |
| 0x41ba1c | Icon data for file with generated extension. Mentioned at [File Extension](#file-extension) |
| 0x41ce8a | JSON data with field `host_hostname`, `host_user`, `host_os`, `host_domain`, `host_arch`, `host_lang`. |
| 0x41cf80 | JSON data with field `disk_name`, `disk_size`, `free_size`. |
| 0x41cffe | JSON object named `disks_info`. |
| 0x41d23c | JSON data with field `bot_version`, `bot_id`, `bot_company`. |
| 0x41d170 | HTTP header data. |
| 0x41d292 | JSON data with field `bot_version`, `bot_id`, `bot_company`, `stat_all_files`, `stat_not_encrypted`, `stat_size`, `execution_time`, `start_time`, `stop_time`. Might be full version of data at 0x41d23c. |
| 0x41d369 | PE file with SHA256 hash: `917e115cc403e29b4388e0d175cbfac3e7e40ca1742299fbdb353847db2de7c2` |
| 0x420ab4 | `SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce`. Registry key for when user shutdowns computer during the encryption? |
| 0x420b1c | `%s -pass`. String used when LockBit tries to execute itself again? |
| 0x420b38 | PE file with SHA256 hash: `63c8efca0f52ebea1b3b2305e17580402f797a90611b3507fab6fffa7f700383`
| 0x421f72 | PowerShell script that attempts to invoke group policy update for the computer in Active Directory. |
| 0x422b67 | String with multiple UUIDs. |
| 0x422d8d | Another string with multiple UUIDs (different one with 0x422b67). |
| 0x4208d5 | `DisablePrivacyExperience`. Used when disabling pricacy settings experience? |
| 0x4209c1 | `DefaultDomainName`. Used for persistence? |
| 0x4209e9 | `DefaultPassw`. Unknown. Fragment of string `DefaultPassword`? |
| 0x4222c3 | Files XML file of the GPP ([ref](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2561ef4d-1dc9-42ee-b2f7-a4df81429fef)). Used to spread file via group policy? |
| 0x4223d8 | ScheduledTasks XML file of the GPP ([ref](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/850b333b-9336-496a-bf93-a20f33748454)). Used to spread scheduled tasks via group policy? |
| 0x42086b | Unknown. |
| 0x42087f | `SOFTWARE\Policies\Microsoft\Windows\OOBE`. Used when disabling pricacy settings experience? |
| 0x42090b | `SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`. Used for persistence? |
| 0x42097b | `AutoAdminLogon`. Used for persistence?
| 0x42099d | `DefaultUserN`. Unknown. Fragment of string `DefaultUserName`? |
| 0x42208a | NTServices XML file of the GPP ([ref](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/c4561a5c-f2fc-4a24-bffc-700d2e00403d)). Used to stop some of the services such as `SQLPBDMS`? |
| 0x42304f | PE file with SHA256 hash: `289ffbeb2d2916c7273b75f4e96ee972b761c8b4d1ae3a84ef3f090e3802d679` |
| 0x422689 | Sets of registry keys. Might be modified on infected system? |
| 0x422810 | Fragment of Administrative Template File ([ref](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/policy/admx-schema)). |
| 0x422974 | NetworkShareSettings XML file of the GPP ([ref](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/06a351b2-152a-49e4-b459-9f698e450834)). Used to share some files among other computers? |

## References

- [Lockbit 3.0で見つけたアンチデバッグテクニック（その１）](https://ameblo.jp/reverse-eg-mal-memo/entry-12773382057.html)
    - Non-English article. I got foothold of anti-debugging technique analysis from here.
- [Anti Debugging Protection Techniques with Examples](https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software#p4)
- [Masquerading Processes in Userland via \_PEB](https://www.ired.team/offensive-security/defense-evasion/masquerading-processes-in-userland-through-_peb)
- [akagi_41.c by api0cradle](https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512)
- [sisoma2/malware_analysis/blackmatter - GitHub](https://github.com/sisoma2/malware_analysis/tree/master/blackmatter)
